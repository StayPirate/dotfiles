#!/usr/bin/env bash
set -euo pipefail
# -----------------------------------------------------------------------------
#                     One tool to rule them all, one tool to containerize them
#                   One tool to bring them all, and in the namespace bind them
#                                  In the Land of Mordor where the shadows lie
#                                        _
#                            ___ ___ ___| |_ ___ _ _ 
#                           |_ -| -_|  _| . | . |_'_|
#                           |___|___|___|___|___|_,_|
#
# Author
# ~~~~~~
#   Gianluca Gabrielli
#   ggabrielli@suse.de
#
# Description
# ~~~~~~~~~~~
#   Secbox is a toolbox which provides you with an out-of-the-box working setup
#   for your daily work in the SUSE Security Team.
#
#   It does not only manage the toolset but it also takes care of mounting the
#   required NFS shared volumes. Think at this as a portable workstation setup.
#   It makes hard use of Podman as container engine, so make sure it's installed
#   on your machine. Your home directory is mounted as home directory within the
#   container, this makes all your dotfiles accessible from the preinstalled
#   tools. The first time you run this script the container will be created.
#   The best way to use this script from your terminal is by leveraging aliases.
#   For instance, you can create an alias like isc="secbox osc -A ibs".
#
# Dependency
# ~~~~~~~~~~
#   * https://podman.io/
#
# -----------------------------------------------------------------------------

print_help () {
    cat <<EOF
Usage: ${_script_name} [--debug] [-h] [-v] [--destroy] [--root] \\
                [--no-color] command [arg1 arg2...]

A collection of all the needed tools for your daily work in the Security Team

Available options:

--destroy [-i]  Destroy ${_container_name} and related components, -i delete the image too
--root          Enter the running container as root user, container debug mode
--debug         Script debug mode
--no-color      Turn off colored output
-h, --help      Print this help and exit
-v, --version   Print component versions
EOF
}

print_logo () {
    msg "${red}\
                _
    ___ ___ ___| |_ ___ _ _ 
   |_ -| -_|  _| . | . |_'_|
   |___|___|___|___|___|_,_|
        ${no_format}"
}

# TODO: cambiare tutte le variabili locali delle funzioni con local var

# TODO: creare una funzione che crei una cartella temporanea e blocchi l'accesso agli altri utenti
# _tmp_dir=create_temp_folder

_tmp_dir=${XDG_RUNTIME_DIR:-/tmp}
_container_name='secbox'
_script_name=$(basename "${BASH_SOURCE[0]}")
_containerfile_url="https://raw.githubusercontent.com/StayPirate/dotfiles/master/.config/containers/containerfiles/secbox"
_containerfile_local="${_tmp_dir}/secbox_containerfile"
_container_unit="${XDG_CONFIG_HOME:-$HOME/.config}/systemd/user/${_container_name}.service"
_local_config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/secbox"
_local_data_dir="${XDG_DATA_HOME:-$HOME/.local/share}/secbox"
_nfs_volumes_dir="${_local_data_dir}/volumes"
_VERSION="0.1"

# dist and mirror are required by `osc omg rr` to perform tests.
declare -a _nfs_shares=(
### address:/share,mountpoint,nfs_version
    "dist.suse.de:/dist,/mounts/dist,4.2"
    "loki.suse.de:/vol/euklid,/mounts/mirror,3"
    #"hilbert.suse.de:/work,/mounts/work,4.2"
    #"rufus.suse.de:/vol/schnell,/mounts/schnell,3"
    #"rufus.suse.de:/vol/work_users,/mounts/work_users,3"
    #"hilbert.suse.de:/built,/mounts/built,4.2"
    #"dust.suse.de:/unpacked,/mounts/unpacked,4.2" # access denied here (╯°□°)╯︵ ┻━┻ ### Need to talk with infra!
)

print_version () {
    _version_str="script\t:\t${_script_name}\tv.${_VERSION}"
    if podman container exists $_container_name; then
        _image_name=$(podman container inspect --format '{{.ImageName}}' ${_container_name} 2>/dev/null)
        _image_version=$(podman container inspect --format '{{.Config.Labels.version}}' ${_container_name} 2>/dev/null)
        _container_status=$(podman container inspect --format '{{.State.Status}}' ${_container_name} 2>/dev/null)
        _version_str="${_version_str}\nimage\t:\t${_image_name}\tv.${_image_version}"
        _version_str="${_version_str}\ncontainer\t:\t${_container_name}\t${_container_status}"
    fi
    echo -e $_version_str | column -t -s $'\t'
}

setup_colors() {
    no_format='' red='' green='' orange='' blue='' purple='' cyan='' yellow=''
    if [[ -t 2 ]] && [[ -z "${no_color:-}" ]] && [[ "${TERM:-}" != "dumb" ]]; then
        no_format='\033[0m'
        red='\033[0;31m'
        green='\033[0;32m'
        orange='\033[0;33m'
        blue='\033[0;34m'
        purple='\033[0;35m'
        cyan='\033[0;36m'
        yellow='\033[1;33m'
    fi
}

msg() {
  echo >&2 -e "${1:-}"
}

die() {
  local msg=${1:-}
  local code=${2:-1} # default exit status 1
  [[ -z $msg ]] || msg "$msg"
  exit "$code"
}

# Configure the container to start at boot
enable_container_service () {
    # If systemd unit does not exist, create it
    systemctl --user status ${_container_name}.service >/dev/null 2>&1 || {
        podman generate systemd --name $_container_name > $_container_unit
        if [[ $? -ne 0 ]]; then 
            msg "${orange}[*]${no_format} Cannot create ${_container_name}.service"
        else
            #####
            # Workaround for bug: https://github.com/containers/podman/issues/8506#issuecomment-735442979
            # FIXME: To be removed once the fix end to the upstream
            sed -e '/^PID/s/^/#/' -i $_container_unit
            #####
        fi

        systemctl --user daemon-reload
    }

    systemctl --user is-enabled --quiet ${_container_name}.service || {
        systemctl --user enable ${_container_name}.service > /dev/null 2>&1
        return $?
    }
}

internal_network_access () {
    # Check if VPN connection is available
    declare -a _required_addresses=(
        "10.160.0.100/111"
        "dist.suse.de/111"
        "gitlab.suse.de/443"
        "download.suse.de/443"
        "github.com/443"
    )

    for _address in ${_required_addresses[@]}; do
        # Fail if any connection can't be estabilished
        (echo > /dev/tcp/$_address) >/dev/null 2>&1 || {
            msg "${orange}[*]${no_format} ${_address%/*} can't be reached on port ${_address#*/}, please check your network setup"
            return 1
        }
    done
    return 0
}

get_containerfile () {
    curl -LfsS $_containerfile_url -o $_containerfile_local
    return 0
}

create_image () {
    internal_network_access || return 1
    _tmp_log=$(mktemp -t "${_container_name}-build-XXXX.log" -p "$_tmp_dir")
    chmod 644 "$_tmp_log"
    msg "[.] building ${_container_name} image from $_containerfile_local"
    msg "\tThis will take several minutes, you can check logs at ${_tmp_log}"
    podman build -t $_container_name\:local -f $_containerfile_local > $_tmp_log 2>&1 || {
        msg "${red}[!]${no_format} Cannot build ${_container_name} image"
        return 1
    }
    msg "${green}[.] ${no_format}building ${_container_name} image complete"
    return 0
}

update_image () {
    read -p "[.] An update is available, do you want to rebuild the image? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Stop not updated running container
        podman container rm -f ${_container_name} > /dev/null 2>&1
        # Delete not update image
        podman image rm localhost/${_container_name}:local > /dev/null 2>&1 || {
            msg "${orange}[*]${no_format} Cannot delete ${_container_name} image, check if it is used by a running container"
            return 1
        }
        create_image
        return $?
    else
        return 0
    fi
    return 1
}

sudo_privs () {
    sudo -nv >/dev/null 2>&1 && return 0 || return 1
}

_nfs_volume_mount_cmd () {
    # $1 name - (e.g.: vol_euklid)
    # $2 address - (e.g.: loki.suse.de:/vol/euklid)
    # $3 nfs_version - (e.g.: 4.2)
    [[ -d "${_nfs_volumes_dir}/${1}" ]] || mkdir -p "${_nfs_volumes_dir}/${1}" > /dev/null 2>&1
    [[ -z "$(ls -A ${_nfs_volumes_dir}/${1})" ]] || return 1 # mountpoint not empty
    sudo mount -t nfs -o vers=$3,ro,noatime,proto=tcp,sec=sys,local_lock=none,rsize=1048576,wsize=1048576 "$2" "${_nfs_volumes_dir}/${1}" 2>&1
    return $?
}

nfs_volume_umount_all () {
    if (mount | grep -E "secbox.+nfs|nfs.+secbox" > /dev/null 2>&1) && ! sudo_privs; then
        msg "${cyan}[*]${no_format} Request sudo privs for ${USER} to umount NFS volumes:"
    fi
    for _share in ${_nfs_shares[@]}; do
        _nfs_address=$(echo $_share | cut -d "," -f 1)              # nfs.example.tld:/a/b
        _nfs_mountpoint=$(echo $_share | cut -d "," -f 2)           # /mount/point
        _nfs_version=$(echo $_share | cut -d "," -f 3)              # 4.2
        _nfs_name=$(echo ${_nfs_address#*/} | sed 's/\//_/')        # nfs.example.tld:/a/b -> a_b
        if nfs_volume_exists "${_nfs_name}" "${_nfs_address}"; then
            sudo umount "${_nfs_volumes_dir}/${_nfs_name}" 2>&1 || return 1
            [[ -z "$(ls -A ${_nfs_volumes_dir}/${_nfs_name})" ]] && rm -r "${_nfs_volumes_dir}/${_nfs_name}"
        fi
    done
    return 0
}

nfs_volume_exists () {
    # $1 name - (e.g.: vol_euklid)
    # $2 address - (e.g.: loki.suse.de:/vol/euklid)
    mount | grep -qE "${1}.+${2}|${2}.+${1}"
    return $?
}

nfs_volume_mount () {
    # $1 nfs share string - nfs_ nfs.example.tld:/a/b,/mount/point,4.2
    _nfs_address=$(echo $1 | cut -d "," -f 1)               # nfs.example.tld:/a/b
    _nfs_mountpoint=$(echo $1 | cut -d "," -f 2)            # /mount/point
    _nfs_version=$(echo $1 | cut -d "," -f 3)               # 4.2
    _nfs_name=$(echo ${_nfs_address#*/} | sed 's/\//_/')    # nfs.example.tld:/a/b -> a_b

    if ! nfs_volume_exists "${_nfs_name}" "${_nfs_address}"; then
        sudo_privs || msg "${cyan}[*]${no_format} Request sudo privs for ${USER} to mount NFS volumes:"
        if _nfs_volume_mount_cmd "${_nfs_name}" "${_nfs_address}" "${_nfs_version}"; then
            msg "${green}[.]${no_format} ${_nfs_name} volume created"
            return 0
        else
            msg "${red}[.]${no_format} cannot create ${_nfs_name} volume"
            return 1
        fi
    else
        return 0
    fi
}

create_container () {
    # If the image does not exist, build it
    podman image ls | grep -E "$_container_name[[:space:]]+local" >/dev/null 2>&1 || {
        msg "${orange}[*]${no_format} ${_container_name} image not found"
        read -p "[.] Do you want to build the image right now? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            create_image || return $?
        else
            return 1
        fi
    }
    
    # this may be removed if user use secbox destroy to delete the container
    systemctl --user stop --quiet $_container_name.service >/dev/null 2>&1
    [[ -f $_container_unit ]] && rm $_container_unit

    # The mounted volume ${_tmp_dir}:${_tmp_dir} (${XDG_RUNTIME_DIR:-/tmp})
    # is usefull for many purpose, most used ones (for me) are:
    #  - Access D-Bus session bus socket
    #    - Used by osc to access the secret service provider to get creds to log in OBS
    #  - mkcd (https://github.com/StayPirate/dotfiles/blob/7608e8ad66f8c13dc57fb49ed0ccf2dd7a04ae5a/.zshrc#L118)

    _podman_cmdline="podman container create \
                        --name $_container_name \
                        --userns=keep-id \
                        -u $(id -u) \
                        -v ${_tmp_dir}:${_tmp_dir} \
                        -v ${HOME}:${HOME} \
                        -w ${HOME}"

    [ -z "${DBUS_SESSION_BUS_ADDRESS:-}" ] || {
        _podman_cmdline="${_podman_cmdline} -e DBUS_SESSION_BUS_ADDRESS=\"${DBUS_SESSION_BUS_ADDRESS}\""
    }

    if internal_network_access; then
        _podman_cmdline_volumes=""
        for _share in ${_nfs_shares[@]}; do
            if nfs_volume_mount "${_share}"; then
                _podman_cmdline_volumes="${_podman_cmdline_volumes} \
                                    -v ${_nfs_volumes_dir}/${_nfs_name}:${_nfs_mountpoint}"
            fi
        done
    else
        msg "${orange}[*]${no_format} No VPN access, you won't have access to NFS volumes.\n \
   This only prevents you to run tests with 'isc omg rr'. You can use ${_script_name} --destroy,\n \
   then connect via VPN and run your command again."
    fi

    _podman_cmdline="${_podman_cmdline} \
                    ${_podman_cmdline_volumes:-} \
                    localhost/$_container_name:local"

    eval $_podman_cmdline > /dev/null 2>&1 || return $?
    enable_container_service
    return 0
}

start_container () {
    # If the container does not exist, create it
    podman container exists $_container_name || {
        print_logo
        msg "${orange}[*]${no_format} ${_container_name} container not found"
        create_container || {
            msg "${red}[!]${no_format} Cannot create the ${_container_name} container"
            return 1
        }
        msg "${green}[.] ${no_format}${_container_name} container created\n"
    }

    systemctl --user is-active --quiet $_container_name.service >/dev/null 2>&1
    _service_status=$?
    case $_service_status in
    0) 
        return 0
        ;;
    3)
        systemctl --user restart $_container_name.service >/dev/null 2>&1
        return $?
        ;;
    *)
        return 1
    esac
}

updated_image_available () {
    _current_v=$(podman image inspect localhost/$_container_name\:local --format "{{.Config.Labels.version}}" 2>/dev/null)
    _latest_v=$(cat $_containerfile_local | grep "LABEL version=" | cut -d "=" -f 2 | sed 's/"//g')
    if [[ "$_latest_v" =~ ^[0-9.]+$ && "$_current_v" =~ ^[0-9.]+$ ]]; then
        if [[ $_latest_v > $_current_v ]]; then
            return 0
        fi
    fi
    return 1
}

systemd_service_is_enabled () {
    systemctl --user is-enabled --quiet ${_container_name}.service
    return $?
}

systemd_service_is_disabled () {
    # Toggle return value
    systemd_service_is_enabled && return 1 || return 0
}

is_container_running () {
    podman container ls --all | grep -qE "Up.*${_container_name}"
    return $?
}

container_is_not_running () {
    # Toggle return value
    is_container_running && return 1 || return 0
}

secbox_exec () {
    # Podman misbehaves when pipes are involved, as reported here
    # https://github.com/containers/podman/issues/9718#issuecomment-799925847
    # Credits to @giuseppe who suggested a clever workaround (_ti)
    ### TODO: add an explanation here for the future
    _ti="-ti"; tty 0<&1 &>/dev/null || _ti=""
    podman container exec $_ti -w "$(pwd)" $_container_name "$@"
}

secbox_destroy (){
    #### TODO: ask for confirmation
    print_logo
    # Stop container if running
    if systemctl --user is-active --quiet $_container_name.service >/dev/null 2>&1; then
        systemctl --user stop --quiet $_container_name.service && msg "${orange}[*]${no_format} container stopped"
    fi
    # Disable autostart at boot
    if systemctl --user is-enabled --quiet ${_container_name}.service >/dev/null 2>&1; then
        systemctl --user disable ${_container_name}.service > /dev/null 2>&1
    fi
    # Remove systemd unit
    if [[ -f $_container_unit ]]; then
        rm $_container_unit
        systemctl --user daemon-reload
        msg "${orange}[*]${no_format} systemd service deleted"
    fi
    # Delete container
    if podman container exists $_container_name; then
        # Get container image id
        _image_id=$(podman container inspect --format '{{.Image}}' ${_container_name} 2>/dev/null)
        if podman container rm -f secbox > /dev/null 2>&1; then
            # If the container has been deleted
            msg "${orange}[*]${no_format} ${_container_name} container deleted"
            # Delete NFS volumes
            if nfs_volume_umount_all; then
                msg "${orange}[*]${no_format} NFS volumes unmounted"
            else
                msg "${orange}[!]${no_format} NFS volumes are still mounted in ${_nfs_volumes_dir}"
            fi
            # Delete image
            if [[ ! -z "${_image_id:-}" ]] && [[ "${1:-}" == "-i" ]]; then
                podman image rm $_image_id > /dev/null 2&>1 && msg "${orange}[*]${no_format} ${_container_name} image deleted"
            fi
        else
            msg "${red}[!]${no_format} ${_container_name} container cannot be deleted"
        fi
    fi
}

secbox_root () {
    # TODO: write a more useful warning here....
    msg "${red}
    !!!  You cannot access the / of the host system from here,  !!!
    !!! but thinking before press enter it's always a good idea !!!
    !!!                     ~ Be CaReFuL ~                      !!!
    ${no_format}"
    podman container exec -ti --user 0 $_container_name bash
}

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~  ~ ~ # 
#         S C R I P T   M A I N          #
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

setup_colors

while :; do
    case ${1:-} in
        -h | --help | help | "") print_help; exit;;
        -v | --version) print_version; exit;;
        --debug) set -x ;;
        --destroy) secbox_destroy ${2:-}; exit;;
        --root) secbox_root; exit ;;
        --no-color) no_color=1 && setup_colors ;;
        -?*) die "${orange}Unknown option${no_format}: ${1:-}" 0 ;;
        *) break ;;
    esac
    shift
done

# Is podman installed?
type podman >/dev/null 2>&1 || die "${red}[!]${no_format} Container engine missing: podman is required"

# FIXME: get_containerfile can be put within update_image_available....
get_containerfile

# Can be converted to already built image
# curl -LsfS https://hub.docker.com/v2/repositories/tuxmealux/alpine-rtorrent | jq -r '.last_updated'
# https://registry.suse.de/v2/_catalog
# http -b https://registry.suse.de/v2/suse/sle-15-sp1/update/cr/images/suse/sle15/tags/list
updated_image_available && update_image

if container_is_not_running; then
    start_container || die "${red}[!]${no_format} Cannot start the ${_container_name} container"
fi

if systemd_service_is_disabled; then
    enable_container_service || msg "${orange}[*]${no_format} Cannot enable ${_container_name} service"
fi

secbox_exec "$@"
